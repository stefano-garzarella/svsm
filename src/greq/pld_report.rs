// SPDX-License-Identifier: MIT OR Apache-2.0
//
// Copyright (C) 2023 IBM
//
// Authors: Claudio Carvalho <cclaudio@linux.ibm.com>

//! `SNP_GUEST_REQUEST` command to request an attestation report.

extern crate alloc;

use core::mem::size_of;

use crate::protocols::errors::SvsmReqError;

/// Size of the `SnpReportRequest.user_data`
pub const USER_DATA_SIZE: usize = 64;

/// MSG_REPORT_REQ payload format (AMD SEV-SNP spec. table 20)
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct SnpReportRequest {
    /// Guest-provided data to be included in the attestation report
    /// REPORT_DATA (512 bits)
    user_data: [u8; USER_DATA_SIZE],
    /// The VMPL to put in the attestation report
    vmpl: u32,
    /// 31:2 - Reserved
    ///  1:0 - KEY_SEL. Selects which key to use for derivation
    ///        0: If VLEK is installed, sign with VLEK. Otherwise, sign with VCEK
    ///        1: Sign with VCEK
    ///        2: Sign with VLEK
    ///        3: Reserved
    flags: u32,
    /// Reserved, must be zero
    rsvd: [u8; 24],
}

impl SnpReportRequest {
    /// Take a slice and return a reference for Self
    pub fn try_from_as_ref(buffer: &[u8]) -> Result<&Self, SvsmReqError> {
        let buffer = buffer
            .get(..size_of::<SnpReportRequest>())
            .ok_or_else(SvsmReqError::invalid_parameter)?;

        let request = unsafe { &*buffer.as_ptr().cast::<SnpReportRequest>() };

        if !request.is_reserved_clear() {
            return Err(SvsmReqError::invalid_parameter());
        }
        Ok(request)
    }

    pub fn is_vmpl0(&self) -> bool {
        self.vmpl == 0
    }

    /// Check if the reserved field is clear
    fn is_reserved_clear(&self) -> bool {
        self.rsvd.into_iter().all(|e| e == 0)
    }
}

///  MSG_REPORT_RSP payload format (AMD SEV-SNP spec. table 23)
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct SnpReportResponse {
    /// The status of the key derivation operation, see [SnpReportResponseStatus]
    status: u32,
    /// Size in bytes of the report
    report_size: u32,
    /// Reserved
    _reserved: [u8; 24],
    /// The attestation report generated by firmware
    pub report: AttestationReport,
}

/// Supported values for SnpReportResponse.status
#[repr(u32)]
#[derive(Clone, Copy, Debug)]
pub enum SnpReportResponseStatus {
    Success = 0,
    InvalidParameters = 0x16,
    InvalidKeySelection = 0x27,
}

impl SnpReportResponse {
    pub fn try_from_as_ref(buffer: &[u8]) -> Result<&Self, SvsmReqError> {
        let buffer = buffer
            .get(..size_of::<SnpReportResponse>())
            .ok_or_else(SvsmReqError::invalid_parameter)?;

        let response = unsafe { &*buffer.as_ptr().cast::<SnpReportResponse>() };
        Ok(response)
    }

    /// Validate the [SnpReportResponse] fields
    ///
    /// # Panic
    ///
    /// * The size of the struct [`AttestationReport`] must fit in a u32
    pub fn validate(&self) -> Result<(), SvsmReqError> {
        if self.status != SnpReportResponseStatus::Success as u32 {
            return Err(SvsmReqError::invalid_request());
        }

        const REPORT_SIZE: usize = size_of::<AttestationReport>();
        assert!(u32::try_from(REPORT_SIZE).is_ok());

        if self.report_size != REPORT_SIZE as u32 {
            return Err(SvsmReqError::invalid_format());
        }

        Ok(())
    }
}

/// The `TCB_VERSION` contains the security version numbers of each
/// component in the trusted computing base (TCB) of the SNP firmware.
/// (AMD SEV-SNP spec. table 3)
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct TcbVersion {
    /// Version of the Microcode, SNP firmware, PSP and boot loader
    raw: u64,
}

/// Format for an ECDSA P-384 with SHA-384 signature (AMD SEV-SNP spec. table 115)
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct Signature {
    /// R component of this signature
    r: [u8; 72],
    /// S component of this signature
    s: [u8; 72],
    /// Reserved
    reserved: [u8; 368],
}

/// ATTESTATION_REPORT format (AMD SEV-SNP spec. table 21)
#[repr(C, packed)]
#[derive(Clone, Copy, Debug)]
pub struct AttestationReport {
    /// Version number of this attestation report
    pub version: u32,
    /// The guest SVN
    pub guest_svn: u32,
    /// The guest policy
    pub policy: u64,
    /// The family ID provided at launch
    pub family_id: [u8; 16],
    /// The image ID provided at launch
    pub image_id: [u8; 16],
    /// The request VMPL for the attestation report
    pub vmpl: u32,
    /// The signature algorithm used to sign this report
    pub signature_algo: u32,
    /// CurrentTcb
    pub platform_version: TcbVersion,
    /// Information about the platform
    pub platform_info: u64,
    /// Flags
    pub flags: u32,
    /// Reserved, must be zero
    reserved0: u32,
    /// Guest-provided data
    pub report_data: [u8; 64],
    /// The measurement calculated at launch
    pub measurement: [u8; 48],
    /// Data provided by the hypervisor at launch
    pub host_data: [u8; 32],
    /// SHA-384 digest of the ID public key that signed the ID block
    /// provided in `SNP_LAUNCH_FINISH`
    pub id_key_digest: [u8; 48],
    /// SHA-384 digest of the Author public key that certified the ID key,
    /// if provided in `SNP_LAUNCH_FINISH`. Zeroes if `AUTHOR_KEY_EN` is 1
    pub author_key_digest: [u8; 48],
    /// Report ID of this guest
    pub report_id: [u8; 32],
    /// Report ID of this guest's migration agent
    pub report_id_ma: [u8; 32],
    /// Report TCB version used to derive the VCEK that signed this report
    pub reported_tcb: TcbVersion,
    /// Reserved
    reserved1: [u8; 24],
    /// If `MaskChipId` is set to 0, Identifier unique to the chip as
    /// output by `GET_ID`. Otherwise, set to 0h
    pub chip_id: [u8; 64],
    /// Reserved and some more flags
    reserved2: [u8; 192],
    /// Signature of bytes 0h to 29Fh inclusive of this report
    pub signature: Signature,
}
